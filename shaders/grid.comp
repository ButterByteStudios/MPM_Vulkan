#version 450

layout(binding = 0) uniform ParameterUBO
{
	float k;
	float mu;
	float rho;
} ubo;

struct Particle
{
	vec4 color;
	vec2 position;
	mat2 F;
	float mass;
};

layout(std430, binding = 1) writeonly buffer GridVelocitySSBOClear
{
	vec2 vClearGrid[];
};

layout(std430, binding = 2) buffer GridVelocitySSBONormalize
{
	vec2 vGrid[];
};

layout(std430, binding = 3) buffer GridMassSSBOIn
{
	float mGrid[];
};

layout (std430, binding = 4) readonly buffer ParticleSSBOIn
{
	Particle particlesIn[];
};

layout(std430, binding = 5) writeonly buffer ParticleSSBOOut
{
	Particle particlesOut[];
};

layout(push_constant) uniform PushConstants {
	float dt;
	float dx;
	float invDx;
	int dimensions;
} pc;

uint index(uint x, uint y)
{
	return x + y * pc.dimensions;
}

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    
    uint i = index(x, y);

	vec2 v = vGrid[i];
	float m = mGrid[i];

	// Reset mass for next steps scatter
	mGrid[i] = 0;
	vClearGrid[i] = vec2(0);

	bool left = x <= 1;
	bool right = x >= pc.dimensions - 2;
	bool down = y <= 1;
	bool up = y >= pc.dimensions - 2;

	if (m == 0 || left || right || down || up)
	{
		// Simple no slip boundary
		vGrid[i] = vec2(0);
		return;
	}

	// Convert momentum to velocity
	vGrid[i] = v / m + vec2(0, -9.81 * pc.dt);
}